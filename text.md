# [1 слайд – логотип NestJS]

Ребят, сегодня расскажу вам немного про такой важный и популярный фреймворк для создания серверных веб-приложений Node.js как NestJS. С того момента, когда NodeJS обрел большую популярность для веб-разработки, за счет своей простоты в освоении и высокой скорости работы, на нем было написано огромное количество бэка. Даже очень крупные компании(Netflix, Uber, eBay) стали использовать его для своего бэка.

# [2 слайд – логотип NodeJS]

Но сам по себе NodeJS это просто платформа для использования JS на стороне сервера, которая предоставляет различные API, обеспечивающие доступ например к файловой системе приложений, http-запросам, потокам. А так как большинство задач в программировании — типовые, если не брать каких-то уж совсем специфических бизнес-кейсов, то скорее всего все возможные задачи уже решены другими программистами и не по одному разу. Каждый раз писать новое решение далеко не лучший вариант, потому что это может быть просто «велосипедом», да и на чистом node.js практически никто не пишет, поэтому на помощь разработчикам приходят фреймворки, которые помогают нам писать меньше шаблонного кода и сосредоточиться на логике приложения.

# [3 слайд - статистика с StateOfJS и RisingStarsJS]

# [4 слайд – логотип Express]

Первым супер-популярным фреймворком стал вышедший в 2010 Express.

## [4 слайд, вертикальный 1]

Его ключевые особенности и преимущества в сравнении с чистой нодой:

- Гибкость(Он предоставляет свободу в выборе архитектуры и решения задач, содержит минимальный уровень абстракции)
- Предлагает надежный механизм маршрутизации для обработки динамических URL-адресов
- Позволяет добавлять дополнительное программное обеспечение в любую точку конвейера обработки запросов.
- Упрощает отладку кода.
- Предоставляет шаблонизатор для динамического рендеринга HTML-страниц на стороне сервера, а не на стороне клиента.
- Хорошо задокументирован.
- Обеспечивает более быструю разработку в сравнении с Node.js.

## [4 слайд, вертикальный 2]

Но несмотря на все его преимущества у него довольно много проблем:

- Гибкость(при отсутствии навыков его использования вы будете совершать ошибки, которые будет сложно отловить, отчасти из-за второго минуса, а так же express не предлагает хороших архитектурных подходов(Беда React). К сожалению, чем более низкоуровневое решение, тем больше свободы у разработчика. И если небольшие приложения на нем писать относительно комфортно, то при масштабировании типичное приложение на Express начинает напоминать большой комок грязи, все слои перемешаны, в одном файле находится контроллер, где есть всё: инфраструктурная логика, валидация, бизнес-логика. Работать с этим больно, поддерживать такой код не хочется. Соответственно нужно очень серьезно продумывать архитектуру при начале проекта)
- В Express.js применяется ES, а не TS(большинство проверок на тип и пустоту требуется осуществлять вручную).
- Сложность поддержки крупных приложений

# [5 слайд - страница NestJS]

И вот наконец в 2017 году вышла первая версия NestJS. Его функциональность превзошла возможности Express.js, предыдущего решения для работы с платформой Node.js. В начале работы с Nest потребуется выучить небольшой объём информации, чтобы правильно все использовать, но когда буквально немного в него окунаешься, все становится очень интуитивным. В остальном он обладает большим преимуществом над Express, даже несмотря на то, что у NestJS под капотом крутится Express. Любые расширения для Express, легко внедрить в Nest. Но это тут не главное, при большом желании Express можно взять и поменять на другой низкоуровневый фреймворк - Fatify. Автор NestJS был вдохновлен идеями Angular, и NestJS получился ну очень похожим на Angular (NestJS и Angular так сильно вместе связаны, что автора фреймворка можно легко встретить на ng конференциях и митапах. Например, недавно команда nrwl включила в свой nx шаблон nestjs.).

## [5 слайд, вертикальный 1]

Перейдем к его особенностям:

- CLI (Чтобы каждый раз не приходилось настраивать проект с нуля, разработчики Nest.js вооружили нас консольной утилитой — @nestjs/cli. Она автоматизирует все базовые операции и ускоряет процесс работы. Например, для автоматического создания структуры нового проекта достаточно выполнить команды: nest new my-first-project. С помощью командной строки код у нас будет генерироваться, как нужно, и прописываться везде, где нужно, что, в свою очередь, значительно ускорит работу. NestJS самостоятельно устанавливает зависимости, а при добавлении новых сервисов и контроллеров распределяет их по директориям и автоматически подключает к соответствующим модулям приложения.)
- Typescript (NestJS, фреймворк, который полностью написан на TypeScript (он также поддерживает JS, но типы уж очень хороши), он легко тестируется и содержит все необходимое. В первую очередь он рассчитан на TypeScript, но благодаря babel можно делать проекты и на JavaScript)
- Платформенно-независим (то есть реализацию HTTP-сервера можете сделать сами (сам NestJS предлагает выбрать Express или Fastify))
- Поддерживает любые протоколы (в добавок к HTTP, например, на основе RabbitMQ, Nats, Kafka или даже просто TCP-протокола.)
- Архитектура (В его основе лежит взятая из Angular 2+ модульность, которая обеспечивает помимо инкапсуляции ещё и dependency injection. Подробно о ней я расскажу позже)
- Тестирование (В Nest интегрировано инженерное тестирование, используется официальная среда тестирования Jest.)

## [5 слайд, вертикальный 2]

- Большое количество библиотек, которые прекрасно интегрируются с Nest (socket.io, passport)
- Интеграция с популярными ORM (TypeORM, Sequelize, Prisma, Mongoose)
- Передовые концепции (например таких как DDD, Event sourcing и микросервисной архитектуре.)
- Декораторы (функционал декларативного программирования, позволяющий расширить любые методы, какие только пожелаем. Их ненавязчивый синтаксис делает логику кода более понятной. Они позволяют писать приложение в более декларативном ключе, указывая что мы хотим сделать, и оставляя детали реализации фреймворку.)
- Обработка ошибок «из коробки»
- Классические импорты

# [6 cлайд - Из чего же состоит NestJS? (Картинка ведьмы)]

Сама загрузка приложения выглядит так:

## [6 слайд, вертикальный 1 (bootstrap)]

Для запуска приложения нам необходимы лишь несколько вещей:

- NestFactory
- Коренной модуль

С помощью NestFactory мы создаем инстанс приложения, а дольше указываем порт на котором мы хотим запустить наше приложение.

Это может показаться очень знакомым тем, кто работал с Express

## [6 слайд, вертикальный 2 (запуск на Express)]

## [6 слайд, вертикальный 3 (Express app через класс)]

В Express неплохим вариантом структурирования логики запуска будет создание вот такого класса. Подобное без проблем можно реализовать и в NestJS

## [6 слайд, вертикальный 4 (Express app через класс)]

Архитектура Nest четко разделяет функциональность и задачи по элементам:

- Modules
- Controllers
- Providers
- Middlewares
- ExceptionFilters
- Pipes
- Guards
- Interceptors
- Custom route decorators

Контроллеры, сервисы, разные обработчики устроены так, что сыоздаётся класс, помечается нужным декоратором (Controller, Injectable). Методы класса тоже помечаются декораторами (Get, Post, Put, Patch, Delete, Message и тд). Зависимости встраиваются через конструктор

## [6 слайд, вертикальный 5 (Структура папки)]

Архитектура подразумевает разделение по фичам и вот стандартная структура папки-фичи, где модуль инкапсулирует логику этого модуля-фичи, контроллер принимает запрос от пользователя, передает нужные данные, например dto в сервис, получает от него результат и возвращает его пользователю

# [7 cлайд - Модули NestJS]

Перейдем к самому главному в NestJS - к модулям.
Самое главное в NestJS - это модуль. Он используется для организации кода и архитектуры приложения. Модуль представляет собой некую абстрактную единицу, которая инкапсулирует в себе некий функционал. Это может быть ваш API, работа с БД, домены, работа с внешними сервисами, конфигурации и тд. Но самое главное - это контекст, который создаёт модуль. Внутри модуля создаётся контекст `DI`-контейнера и через него разрешаются зависимости (`Injectable services`).

## [7 слайд, вертикальный 1 (Структура модулей)]

Каждое приложение Nest имеет как минимум один модуль, корневой модуль. Корневой модуль - это место, где Nest начинает упорядочивать дерево приложений. Фактически, корневой модуль может быть единственным модулем в вашем приложении, особенно когда приложение маленькое, но это не имеет смысла. В большинстве случаев у вас будет несколько модулей, каждый из которых имеет тесно связанный набор возможностей.)

## [7 слайд, вертикальный 2 (Код модуля)]

Это класс с декоратором `@Module()`. Декоратор `@Module()` предоставляет метаданные, которые Nest использует для организации структуры приложения.

В контролеры и провайдеры попадают соответственно контроллеры и провайдеры этого модуля
В импорты другие модули, для того, чтобы например `UserService` мог инжектировать с помощью DI `DatabaseService` и использовать его
Ну и в экспорты то, что затем другие модули смогут использовать

# [8 cлайд - Контроллеры NestJS]

Они отвечают за обработку входящих запросов и возврат ответов клиенту. А также за роутинг, парсинг параметров, в общем за всё, что касается принятия и отдачи по запросу.

## [8 слайд, вертикальный 1 (Контроллер NestJS)]

Мы используем декоратор `@Controller` для создания контроллера. Мы определяем опциональный префикс пути (path prefix) posts. Использование префикса пути в Controller позволяет группировать набор связанных роутов и минимизировать повторяющийся код. Например, мы можем сгруппировать набор роутов для работы с постами с помощью префикса posts. Использование префикса пути избавляет от необходимости дублировать его в каждом роуте контроллера

C помощью DI мы внедряем нас сервис работы с постами

Дальше с помощью декораторов мы можем определить метод запроса и как он будет обрабатываться. В NestJS присутствуют декораторы для всех методов.

Далее NestJS опять предоставляет нам очень приличный набор декораторов, которые реализуют функционал, например получения параметров запроса или тела запроса, что избавляет нас от постоянных обращений к полям объекта запроса и делает код значительно читабильнее

Также иногда может возникнуть небходимость изменить код ответа на запрос, например вместо кода 201 отправить код 200. В Express мы бы делали это через response.status(200), NestJS же предоставляет декоратор рута `@HttpCode`, в который мы можем поместить нужный нам статус. Обратите внимание, что в NestJS есть очень удобный enum HttpStatus в котором под человекочитабельными названиями находятся все коды ответа, что также сильно поднимает читабельность кода.

Декоратор `@Header` позволяет определять заголовки ответа

В NestJS в целом очень много уже готовых инструментво, которые в Express мы бы так или иначе делали самостоятельно, а здесь они реализованы в удобной форме, что экономит разработчикам время.

## [8 слайд, вертикальный 2 (Контроллер Express)]

А вот пример точно такого же контроллера, написаного для Express

Нам нужно вручную вызывать router, создавать инстанс сервиса, инициализировать руты

Это хороший подход для реализации на Express, но количество кода больше, чем в NestJS и код менее читабелен

## [8 слайд, вертикальный 3 (DTO)]

NestJS поддердивает очень удобную валидацию запроса, причем как тела запроса, так и query, params с помощью библиотеки `class-validator`, когда мы указываем в аргументе функции обработчика рута какой-то `dto`, то NestJS запускает pipe, который обрабатывает данные перед тем, как они пападают в контроллер. И с помощью огромного набора декораторов мы можем валидировать приходящие к нам данные. О pipes чуть позже.

## [8 слайд, вертикальный 4 (Decorators)]

Для работы с содержанием запроса NestJS предоставляет вот такой набор декораторов, которые позволяют нам получить, например, всю строку запроса, или выдернуть какой-то элемент этой строки, передав его название в декоратор `@Query("access_key")`, чтобы нам не делать это вручную.

NestJS дает нам даже возможность получить IP, с которого пришел запрос.

Кто-то может сказать что в NestJS огромный уровень абстракции и будет на 100% прав, но ведь большинство задач все равно будут вертеться именно вокруг таких задач, которые NestJS покрывает своими абстракциями, а для случаев когда все-таки абстракция мешает или не предоставляет такой функционал, который нам необходим, мы всегда можем получить доступ к объектам запроса и ответа с помощью декораторов и работать с ними напрямую, как в Express.

## [8 слайд, вертикальный 4 (Custom decorator)]

# [9 cлайд - Провайдеры NestJS]

Почти все в NestJS является Providers — Service, Repository, Factory, Helper и т.д. Они могут быть внедрены в контроллеры и другие провайдеры. Если сказать языком Angular — то это все `@Injectables`

## [9 слайд, вертикальный 1 (Services)]

Сервисы в NestJS это классы которые уже непосредственно реализуют всю ту логику, которая заключена между получением запроса и отправкой ответа

Помечается такой класс декоратором `@Injectable`, в конструкторе, уже привычно с помощью DI встраивается сервис с который нам необходим

В самом классе находятся те методы, в которых реализуется логика по сути всего модуля.

Обратите внимание на 19 строчку, где мы обрабатываем ошибку. Здесь мы переходим к работе со слоем фильтра исключений. О нем я расскажу через один слайд.

## [9 слайд, вертикальный 2 (Services)]

Вот еще пример провайдера. В данном случае это сервис, который используя базовый `ConfigService` получает переменные окружения, обрабатывает их и предоставляет наружу. Еще один пример того, как архитектура NestJS разделяет логику по функционалу.

По сути провайдеры оборачивают логику, библиотеки, подключения к базам данныъ, как делается в Angular, что позволяет затем легко изменить что-то только в провайдере, не переписывая код потребителей провайдера

# [10 cлайд - Exception Filters NestJS]

В Nest есть слой исключений, в обязанности которого входит перехват необработанных исключений и возврат соответствующего ответа конечному пользователю. В тех случаях, когда мы забыли сделать кастомную обработку ошибок, мы все равно получим данные по ним. Nest предоставляет встроенный класс HttpException. Конструктор HttpException принимает 2 обязательных параметра, определяющих ответ:

- параметр response определяет тело ответа. Он может быть строкой или объектом;
- параметр status определяет статус-код;

Каждое исключение обрабатывается глобальным фильтром исключений, и когда оно не распознается (не HttpException или класс, который наследует HttpException), пользователь получает следующий ответ JSON:

## [10 слайд, вертикальный 1 (Exceptions)]

NestJS дает нам сразу готовые обертки ошибок на наиболее распространенные исключения, все что нам остается - передать или нет в конструктор кастомное сообщение об ошибке

В этом куске кода у нас два разных способа вернуть одну и ту же ошибку. Это пример абстракции, который снижает количество кода и повышает читабельность.

# [11 cлайд - Pipes NestJS]

## [11 слайд, вертикальный 1 (Pipes used for...)]

Pipes — выполняет две роли. Первая — это преобразование одного типа в другой, преобразует входные данные в желаемый результат. Например, когда у вас ID ожидается строкой, а пришло число, и чтобы не страдать преобразованием типов на фронте, pipe реализует это на беке. Вторая функция — это проверка соответствия типов, валидация входящих данных.

Конвейер — это класс, аннотированный с помощью декоратора @Injectable и реализующий интерфейс PipeTransform.

## [11 слайд, вертикальный 2 (Встроенные конвейеры)]

Nest предоставляет 8 встроенных конвейеров

## [11 слайд, вертикальный 3 (Использование pipes)]

Для применения конвейера нам необходимо привязать его экземпляр к соответствующему контексту. На уровне метода это можно сделать следующим образом:

После этого если мы отправим GET-запрос к конечной точке http://localhost:3000/abc, Nest выбросит такое исключение:

## [11 слайд, вертикальный 4 (Кастомный валидационный pipe)]

Вот пример кастомного pipe валидации, но существует другой, более простой способ: библиотека class-validator позволяет выполнять валидацию с помощью декораторов. Это я вам уже показывал.

# [12 cлайд - Middleware NestJS]

## [12 слайд, вертикальный 1 (Middleware flow)]

Посредник — это функция, которая вызывается перед обработчиком маршрута. Посредники имеют доступ к объектам запроса и ответа, а также к посреднику next в цикле запрос-ответ.

По умолчанию посредники Nest аналогичны посредникам Express.

- выполнение любого кода;
- модификация объектов запроса и ответа;
- завершение цикла запрос-ответ;
- вызов следующего посредника в стеке;
- если текущий посредник не завершает цикл запрос-ответ, он должен вызвать next() для передачи управления следующему посреднику. В противном случае, запрос зависнет (hanging).

## [12 слайд, вертикальный 2 (Кастомный Middleware )]

Кастомный посредник может быть реализован как в виде функции, так и в виде класса с помощью декоратора @Injectable. Класс должен реализовывать интерфейс NestMiddleware, а к функции особых требований не предъявляется. Начнем с реализации посредника в виде класса:

## [12 слайд, вертикальный 3 (Кастомный Middleware-функция)]

Простые middleware можно реализовать в виде функции. У него нет членов, дополнительных методов и зависимостей.

## [12 слайд, вертикальный 4 (Регистрация Middleware )]

В декораторе Module нет места для посредников. Поэтому мы применяем их в с помощью метода configure класса модуля. Модули, включающие посредников, должны реализовывать интерфейс NestModule.

В метод apply мы передаем те посредники, которые желаем применить к модулю. Для применения нескольких посредников достаточно передать их методу apply через запятую

MiddlewareConsumer — это вспомогательный класс. Он предоставляет несколько встроенных методов для управления посредником. Данные методы могут вызываться по цепочке. Метод forRoutes принимает строку, несколько строк или объект RouteInfo, класс контроллера или несколько таких классов. В большинстве случаев мы передаем этому методу контроллеры, разделенные запятыми.

Иногда мы не хотим, чтобы посредник применялся к определенным роутам. Исключить такие роуты можно с помощью метода exclude, который принимает строку, несколько строк или объект RouteInfo

## [12 слайд, вертикальный 5 (Регистрация глобального Middleware )]

Для применения посредника ко всем роутам приложения можно использовать метод use, предоставляемый экземпляром INestApplication

# [13 cлайд - Guards NestJS]

## [13 слайд, вертикальный 1 (Guard flow)]

Guards имеют единственную ответсвенность. Они определяют, должен ли запрос обрабатываться обработчиком маршрута или нет.

> Обратите внимание: Guards выполняются после посредников, но перед перехватчиками и конвейерами.

Guards предназначены для авторизации — определения того, передавать ли запрос обработчику маршрута для дальнейшей обработки, в зависимости от определенных условий (разрешения, роли пользователя и т.д.). Защитники, в отличие от посредников, имеют доступ к экземпляру ExecutionContext и по этой причине точно знают, какой код будет выполняться следующим.

## [13 слайд, вертикальный 2 (Guard)]

Guard - это класс, аннотированный с помощью декоратора `@Injectable` и реализующий интерфейс `CanActivate`.

Функция canActivate должна возвращать логическое значение — индикатор валидности текущего запроса:

- если она возвращает true, запрос будет передан обработчику;
- если она возвращает false, запрос будет отклонен с ошибкой.

Для доступа к кастомным метаданным в защитнике используется вспомогательный класс Reflector

> canActivate() принимает один параметр — экземпляр ExecutionContext. ExecutionContext наследует от ArgumentsHost. ExecutionContext расширяет ArgumentsHost несколькими вспомогательными методами, предоставляющими дополнительную информацию о текущем процессе выполнения (обработке запроса).

## [13 слайд, вертикальный 3 (Use of Guard)]

## [13 слайд, вертикальный 4 (Custom metadata decorator)]

Если пользователь, который не подтвердил свою почту, попытается создать пост, он получит такую ошибку:

# [14 cлайд - Interceptors NestJS]

Перехватчики имеют ряд полезных возможностей, которые вдохновлены техникой Aspect-Oriented Programming (AOP). Они позволяют:

- привязать дополнительную логику до / после выполнения метода;
- преобразовать результат, возвращаемый функцией;
- преобразовать исключение, выброшенное из функции;
- полностью переопределить функцию в зависимости от выбранных условий (например, для кэширования).

## [14 слайд, вертикальный 1 (Interceptors flow)]

## [14 слайд, вертикальный 2 (Interceptor)]

Перехватчик — это класс, аннотированный с помощью декоратора @Injectable и реализующий интерфейс NestInterceptor.

Каждый перехватчик реализует метод intercept, принимающий 2 параметра. Первым параметром является экземпляр контекста выполнения (ExecutionContext), о котором рассказывалось в разделе, посвященном защитникам. Второй параметр — обработчик вызова (CallHandler).

Интерфейс CallHandler реализует метод handle, который используется для вызова метода обработчика маршрута для передачи ему управления. Если не вызвать handle в intercept, метод обработчика не будет выполнен.

Перехватчики позволяют выполнять кастомную логику как до, так и после вызова метода обработчика. С "до" все ясно, но что позволяет перехватчику выполнять код "после"? Дело в том, что handle возвращает Observable. Это позволяет использовать мощные операторы RxJS для дальнейшей манипуляции ответом. В терминологии аспектно-ориентированного программирования это называется точечным разрезом (pointcut) — мы вставляем в эту точку дополнительную логику.

> Перехватчики отлично подходят для создания повторно используемых решений. Предположим, что мы хотим заменять все null на пустую строку ('').

Первым случаем использования перехватчиков является фиксирование взаимодействия пользователя со страницей

Для установки перехватчика используется декоратор @UseInterceptor из пакета @nestjs/common. Подобно конвейерам или защитникам, перехватчики могут устанавливаться на уровне контроллеров, методов или глобально.

Для установки глобального перехватчика используется метод useGlobalInterceptor экземпляра приложения Nest:
